/**
 * Created by xiaoxiao on 2017/4/6.
 */
//  //                                  简洁表示法  //////////////////////////////////////////////
var foo = 'bar';
var baz = {foo};
console.log(baz); // Object {foo: "bar"}

// 等同于
var aaa= {foo: foo};
console.log(aaa);// Object {foo: "bar"}


 //     ///////////////////////      属性名表达式    ————- 表达式做属性名       //////////////////////////////////////////////
var obj={
    ['a'+'b']:123
};
console.log(obj);//Object {ab: 123}

var obj={
    [1+2]:123
};
console.log(obj);//Object {3: 123}
console.log(obj[3]);//123



    ////////////////////////////////////////////   //////////////////////////////////////////////   //////////////////////////////////////////////
            //                  简洁表示法 和    属性名表达式   不能同时使用   //////////////////////////////////////////////
    ////////////////////////////////////////////   //////////////////////////////////////////////   //////////////////////////////////////////////
var foo = 'bar';
var bar = 'abc';
var baz = { [foo] };// Uncaught SyntaxError: Unexpected token }

var foo='bar';
var bar={[foo]:'aaaaa'};
console.log(bar);//Object {bar: "aaaaa"}


// //////////////////////////////    对象方法也是函数，也有name属性  、、、、、、、



///////////////////////////////////////////   //////////////////////////////////////////////   //////////////////////////////////////////////
  //  ES5中  比较两个值是否相等  ==与===都有缺点（== 会自动转换类型，===中NaN不等于NaN，+0等于-0）/////////////////////////////////////////////   //////////////////////////////////////////////   //////////////////////////////////////////////
 //  ES6   Object.is()  与===行为基本一致，但是！！！！这个新方法NaN等于NaN,+0不等于-0！！！！！！！/////////////////////////////////////////////   //////////////////////////////////////////////   //////////////////////////////////////////////
///////////////////////////////////////////   //////////////////////////////////////////////   //////////////////////////////////////////////
console.log(Object.is(+0,-0));//false
console.log(Object.is(NaN,NaN));//true



///////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
//                 Object.assign(目标对象，后面的都是源对象)    对象合并                                                  //////////////////////////////////////////////   /////////////////////////
///////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
var target = { a: 1 };
var source1 = { b: 2 };
var source2 = { c: 3 };
Object.assign(target, source1, source2);
console.log(target);// Object {a: 1, b: 2, c: 3}


var target = { a: 1, b: 1 };
var source1 = { b: 2, c: 2 };
var source2 = { c: 3 };
Object.assign(target, source1, source2);
console.log(target);/// Object {a:1, b:2, c:3}   //后面覆盖前面的

//  //Object.assign方法实行的是！！！！浅拷贝！！！！而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。



/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
// //   // 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。

// //ES5有三个操作会忽略enumerable为false的属性。   （比如不可枚举的属性length）
// //for...in循环：只遍历对象自身的和继承的可枚举的属性
// //Object.keys()：返回对象自身的所有可枚举的属性的键名
// //JSON.stringify()：只串行化对象自身的可枚举的属性

//  //还有ES6的Object.assign也会忽略不可枚举的属性
//////////////////////////////////////////////   /////////////////////////
/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////





/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
// //                                           属性遍历                           //////////////////////////////////////////////   /////////////////////////
/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
// // for...in...
// // Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。
// //Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。
// //Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。
// //Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。
// //以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。

// //首先遍历所有属性名为数值的属性，按照数字排序。
// //其次遍历所有属性名为字符串的属性，按照生成时间排序。
// //最后遍历所有属性名为Symbol值的属性，按照生成时间排序。
// console.log(Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }));//["2", "10", "b", "a", Symbol()]
// //



/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
// //     __proto__属性（前后各两个!!!!下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。                         //////////////////////////////////////////////   /////////////////////////
/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////




/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
// //   Object.setPrototypeOf()
// // Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。 //////////////////////////////////////////////   /////////////////////////
/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////




/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
// //  Object.getPrototypeOf()用于读取一个对象的原型对象 //////////////////////////////////////////////   /////////////////////////
/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////

// // undefined或null，它们无法转为对象!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////
// //  Object.values只返回对象自身的可遍历属性 ,会过滤属性名为 Symbol 值的属性    //////////////////////////////////////////////   /////////////////////////
/////////////////////////////////////////////   //////////////////////////////////////////////   ///////////////////////////////////////







