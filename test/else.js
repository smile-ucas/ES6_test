/**
 * Created by xiaoxiao on 2017/4/8.
 */
//在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。
//字符串是一个类似数组的对象，也原生具有Iterator接口。

//一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，
//就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。


//for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、
//Generator 对象，以及字符串。

let map=new Map().set('a',1).set('b',2);
for(let i of map){
    console.log(i);//["a", 1]   ["b", 2]
}
for(let [key,value] of map){
    console.log(key+' : '+value);//a : 1      b : 2
}

//entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；
//对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。
//keys() 返回一个遍历器对象，用来遍历所有的键名。
//values() 返回一个遍历器对象，用来遍历所有的键值。


//对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，
// //for...in循环依然可以用来遍历键名。!!!!注意是键名 不是键值！！！！！！！！！！
let es6 = {
    edition: 6,
    committee: "TC39",
    standard: "ECMA-262"
};
for (let e in es6) {
    console.log(e);
}
// edition
// committee
// standard

//使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。
let es6 = {
    edition: 6,
    committee: "TC39",
    standard: "ECMA-262"
};
for(let key of Object.keys(es6)){
    console.log(key+' : '+es6[key]);
}
//edition : 6
//committee : TC39
//standard : ECMA-262





// // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   // //async函数返回一个 Promise 对象，可以使用then方法添加回调函数。
//当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
// // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//



// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，
// //新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了!!!!!!
// //另外，方法之间不需要逗号分隔，!!!!     加了会报错。
//定义
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}
console.log(typeof Point);//function          所以！！ 类完全可以看作构造函数的另一种写法

// //类的内部所有定义的方法，都是不可枚举的（non-enumerable）!!!!!!!!!!!!
// //Class不存在变量提升（hoist），这一点与ES5完全不同。
// //必须保证子类在父类之后定义。



// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。
// //其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。
// //ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// // ES6模块
// import { stat, exists, readFile } from 'fs';


//ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";。
//一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取!!!!!!!!!!
//如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。
// profile.js
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;
//上下两种写法
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;
export {firstName, lastName, year};
// //上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。
export {
    v1 as streamV1,
    v2 as streamV2,
    v2 as streamLatestVersion   //重命名后，v2可以用不同的名字输出两次。
};//使用as为要输出的变量重命名



// //export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，import命令也是如此。
// //这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。
//import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。
//  // 加载     大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同!!!!!!!!!!!!!!!!!!
// main.js
import {firstName, lastName, year} from './profile';
import { lastName as surname } from './profile'; //也可以重命名

// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //    import命令具有提升效果！！！！！！！！！！！！！！！！提升到整个模块的头部，首先执行
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构





// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //             export default命令，为模块指定默认输出。    一个模块只能有一个默认输出，因此export default命令只能使用一次
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //
              //  !!!!!!!!!!!!!!!!!1        模块脚本自动采用严格模式，不管有没有声明use strict!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
//CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
//一句话，defer是“渲染完再执行”，async是“下载完就执行”。
 //另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。
//浏览器对于带有type="module"的<script>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script>标签的defer属性。


// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。
//以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。
//也就是说，!!!!!!!!!!!!!!1CommonJS模块无论加载多少次，都只会在第一次加载时运行一次!!!!!!!!!!!!!!!!!!!!!!!!
//以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //
//如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。








// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //
// // // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //